============================================================================
■■■T-Kernel 2.0ソースコードパッケージ Ver 2.01.00 修正箇所
								2011/09/08

■T-Kernel Ver 2.01.00 修正箇所

----
[K-201-1]バージョン番号をVer 2.01.00に変更

【修正内容】
ProductVer を 0x0200 から 0x0201 に修正。
バージョン文字列を 2.00.00 から 2.01.00 に修正。

【修正ファイル】
config/launch-ramkernel/src/sysdepend/tef_em1d/SYSCONF
config/src/sysdepend/tef_em1d/SYSCONF
kernel/sysmain/src/sysmain.h

----
[K-201-2]tk_cre_mpl(),tk_get_mpl()のエラー検出

【旧版での問題点】
tk_get_mpl() の blksz として 0x7ffffff9 〜 0x7fffffff を指定した場合に、
エラーではなく正常終了になってしまう。

これは、blksz の割り当て単位への丸め(切り上げ)の処理を行う結果、内部処理上の
blksz が 0 になってしまい、エラーが検出されなくなるのが原因。

tk_get_mpl_u() も同様。

また、tk_cre_mpl() の pk_cmpl->mplsz にも同様の問題があり、0x7ffffff9 以上を
指定した場合に、エラーではなく正常終了になってしまう。

【修正内容】
上記のような条件でもエラーを返すように修正した。

【修正ファイル】
kernel/tkernel/src/mempool.c

----
[K-201-3]tk_opn_dev(),tk_cls_dev():オープン処理とクローズ処理の順序関係

【旧版での問題点】
同一デバイスに対して複数のタスクから同時にオープンまたはクローズの要求が
あった場合に、デバイスドライバのオープン／クローズ関数の終了と、
tk_opn_dev(),tk_cls_dev()の終了との順序関係が、期待通りにならない場合があった。

障害が発生するのは、TDA_OPENREQ 属性が指定されていない場合である。

障害の発生例:

(A)複数のタスクから同時にオープンした場合
    1. task1 が tk_opn_dev() を呼び出す。
    2. デバイスドライバの openfn が呼び出される。(まだ戻らない)
    3. task2 が tk_opn_dev() を呼び出す。
    4. TDA_OPENREQ 指定がないので、デバイスドライバの openfn は呼び出されない。
    5. task2 の tk_opn_dev() が完了する。
       この時点で 2. のデバイスドライバーの openfn はまだ終了していない。

  このように、デバイスドライバーの openfn の処理完了を待たずに、tk_opn_dev()が
  完了してしまう場合があった。

(B)クローズ中にオープンされた場合
    1. task1 が tk_cls_dev() を呼び出す。
    2. デバイスドライバの closefn を呼び出す前に、task2 に切り替わる。
    3. task2 が tk_opn_dev() を呼び出す。
    4. デバイスドライバの openfn を呼び出す。
    5. task2 の tk_opn_dev() が完了する。
    6. task1 に切り替わり、デバイスドライバーの closefn を呼び出す。
    7. task1 の tk_cls_dev() が完了する。

  このように、オープンが完了しているにもかかわらず、デバイスドライバから見ると
  最後に呼び出されるのが closefn となる場合があった。

なお、TDA_OPENREQ が指定された場合は、デバイスドライバのオープン／
クローズ関数が毎回呼び出されるため、実質的には問題にならない。

【修正内容】
上記の障害に対して、オープンまたはクローズの処理中は、他のタスクからの
オープン／クローズ要求を待たせるように修正した。

【修正ファイル】
kernel/sysmgr/src/device.c
kernel/sysmgr/src/deviceio.c
kernel/sysmgr/src/sysmgr.h

----
[K-201-4]tk_srea_dev(),tk_swri_dev():アボートと複数要求待ち

【旧版での問題点】
同期型入出力(tk_srea_dev tk_swri_dev)において、次のような状況の時、
デバイスドライバへの要求が完了せずに放置されてしまうことがあった。

 (A)同期入出力の処理途中でアボートが発生すると、同期入出力の内部処理の
    tk_wai_dev() がアボートを検出してエラー(E_ABORT)になり、要求を完了せ
    ずに戻ってしまう場合があった。

 (B)他のタスクが tk_wai_dev() による複数要求待ちをしているときに同期入出
    力を行うと、(複数要求待ち中は、同時に他の要求待ちはできないため)同期
    入出力の内部処理の tk_wai_dev() がエラー(E_OBJ)になり、要求を完了せ
    ずに戻ってしまう場合があった。

【修正内容】
上記のような状況でも正常に動作するように、tk_srea_dev(),tk_swri_dev()の
処理を修正した。

【修正ファイル】
kernel/sysmgr/src/device.c
kernel/sysmgr/src/deviceio.c
kernel/sysmgr/src/sysmgr.h

============================================================================
■T-Monitor Ver 2.01.00 修正箇所

----
[M-201-1]バージョン番号をVer 2.01.00に変更

【修正内容】
VER を 2.00.00 から 2.01.00 に修正。

【修正ファイル】
monitor/tmmain/build/tef_em1d/Makefile

----
[M-201-2]Exitコマンド実行時のタッチパネル割込み禁止

【旧版での問題点】
Exit後にタッチパネルに触れると再起動してしまう場合があった。

【修正内容】
電源OFF時の処理を整理し、powerOff()、usbPower()、resetStart()を追加して、
電源OFF時にはこれらの関数を呼び出すようにした。
また、powerOff()内でタッチパネル割り込みを禁止する処理を追加した。

【修正ファイル】
monitor/hwdepend/tef_em1d/src/config.c
monitor/hwdepend/tef_em1d/src/system.c

----
[M-201-3]cpuLED()の処理

【旧版での問題点】
LEDの点灯状況によっては、LED5〜LED8に接続されているGPIOを制御する
cpuLED()の動作が、引数の意図通りにならない場合があった。

なお、cpuLED()はT-Monitorの起動時/終了時にのみ呼び出され、
通常のT-Monitorの利用では問題にならない。問題が起こるのは、
cpuLED()を呼び出すようなプログラムを自分で書いた場合である。

【修正内容】
cpuLED()の処理内容を修正した。

【修正ファイル】
monitor/hwdepend/tef_em1d/src/config.c

============================================================================
■T-Kernel用ドライバ 修正箇所

[D-201-1]時計ドライバで設定するSPIの極性

【旧版での問題点】
Audio CODEC(SPI0:CS1)および温度センサ(SPI2:CS0)のCS線の極性が
正しく設定されておらず、アクセスできない状態になっていた。

【修正内容】
正常な設定値となるように修正した。

【修正ファイル】
drv/tef_em1d/clk/src/em1d512_spi.c

									以上
============================================================================
